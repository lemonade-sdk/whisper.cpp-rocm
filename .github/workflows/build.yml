name: CI

on:
  push:
    branches:
      - master
    tags:
      - 'v*'
    paths: ['.github/workflows/build.yml',
            '**/CMakeLists.txt',
            '**/Makefile',
            '**/*.mk',
            '**/*.cmake',
            '**/*.in',
            '**/*.h',
            '**/*.hpp',
            '**/*.c',
            '**/*.cpp',
            '**/*.cu',
            '**/*.cuh',
            '**/*.cl',
            '**/*.swift',
            '**/*.m',
            '**/*.mm',
            '**/*.metal',
            '**/*.comp',
            '**/*.java']

  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      create_release:
        description: 'Create new release'
        required: true
        type: boolean
      pre_release_tag:
        description: 'Pre-release tag name'
        required: false
        type: string
      run_type:
        description: 'Workflow type to run'
        required: true
        type: choice
        options:
          - full-ci
          - release-only
      gfx_target:
        description: 'AMD GPU targets (comma-separated)'
        required: false
        default: 'gfx1151,gfx1150,gfx120X,gfx110X'
      rocm_version:
        description: 'ROCm version to use (e.g., 7.11.0a20251205) or "latest" to auto-detect'
        required: false
        default: 'latest'

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref && github.ref || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: write  # for creating release

env:
  BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
  ubuntu_image: "ubuntu:22.04"
  VCPKG_BINARY_SOURCES: "clear;x-gha,readwrite"
  GFX_TARGETS: ${{ github.event.inputs.gfx_target || 'gfx1151,gfx1150,gfx120X,gfx110X' }}
  ROCM_VERSION: ${{ github.event.inputs.rocm_version || 'latest' }}

jobs:
  determine-tag:
    runs-on: ubuntu-latest
    outputs:
      tag_name: ${{ steps.tag.outputs.name }}
      should_release: ${{ steps.tag.outputs.should_release }}
    steps:
      - name: Checkout with full history
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
      - name: Determine tag name
        id: tag
        shell: bash
        run: |
          BUILD_NUMBER=$(git rev-list --count HEAD)
          SHORT_HASH=$(git rev-parse --short=7 HEAD)
          CUSTOM_TAG="${{ github.event.inputs.pre_release_tag }}"
          SHOULD_RELEASE="false"

          echo "Raw values:"
          echo "BUILD_NUMBER: $BUILD_NUMBER"
          echo "SHORT_HASH: $SHORT_HASH"
          echo "BRANCH_NAME: ${{ env.BRANCH_NAME }}"
          echo "CUSTOM_TAG: $CUSTOM_TAG"

          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            echo "Using pushed tag name"
            TAG_NAME="${{ github.ref_name }}"
            SHOULD_RELEASE="true"
          elif [[ -n "$CUSTOM_TAG" ]]; then
            echo "Using custom tag"
            TAG_NAME="${CUSTOM_TAG}"
            SHOULD_RELEASE="true"
          elif [[ "${{ github.event.inputs.create_release }}" == "true" ]]; then
            echo "Manual release requested"
            SHOULD_RELEASE="true"
            TAG_NAME="b${BUILD_NUMBER}"
          elif [[ "${{ env.BRANCH_NAME }}" == "master" ]]; then
            echo "Using master branch format"
            TAG_NAME="b${BUILD_NUMBER}"
            SHOULD_RELEASE="false"
          else
            echo "Using non-master branch format"
            SAFE_NAME=$(echo "${{ env.BRANCH_NAME }}" | tr '/' '-')
            TAG_NAME="${SAFE_NAME}-b${BUILD_NUMBER}-${SHORT_HASH}"
            SHOULD_RELEASE="false"
          fi

          echo "Final tag name: $TAG_NAME"
          echo "Should release: $SHOULD_RELEASE"
          echo "name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT

  prepare-matrix:
    runs-on: ubuntu-latest
    outputs:
      windows_matrix: ${{ steps.set-matrix.outputs.windows_matrix }}
      ubuntu_matrix: ${{ steps.set-matrix.outputs.ubuntu_matrix }}
      should_build_windows: ${{ steps.set-matrix.outputs.should_build_windows }}
      should_build_ubuntu: ${{ steps.set-matrix.outputs.should_build_ubuntu }}
    steps:
    - name: Set matrix
      id: set-matrix
      run: |
        targets="${{ env.GFX_TARGETS }}"
        operating_systems="windows,ubuntu"
        
        echo "Input targets: $targets"
        echo "Input operating systems: $operating_systems"

        target_array=$(echo "$targets" \
          | tr ',' '\n' \
          | sed 's/^ *//;s/ *$//' \
          | sed 's/^"//;s/"$//' \
          | jq -R . \
          | jq -s .)

        windows_matrix=$(echo "$target_array" \
          | jq -c '{gfx_target: ., sdl2: ["ON"], build: ["Release"], arch: ["x64"], s2arc: ["x64"], s2ver: ["2.28.5"]}')

        # 3. Create Ubuntu Matrix
        ubuntu_matrix=$(echo "$target_array" \
          | jq -c '{gfx_target: ., sdl2: ["ON"], build: ["Release"], arch: ["linux/amd64"]}')

        # Check which operating systems to build
        should_build_windows="false"
        should_build_ubuntu="false"
        
        if [[ "$operating_systems" == *"windows"* ]]; then
          should_build_windows="true"
          echo "windows_matrix=$windows_matrix" >> $GITHUB_OUTPUT
        fi
        
        if [[ "$operating_systems" == *"ubuntu"* ]]; then
          should_build_ubuntu="true"
          echo "ubuntu_matrix=$ubuntu_matrix" >> $GITHUB_OUTPUT
        fi
        
        echo "should_build_windows=$should_build_windows" >> $GITHUB_OUTPUT
        echo "should_build_ubuntu=$should_build_ubuntu" >> $GITHUB_OUTPUT
        
        echo "Windows build: $should_build_windows"
        echo "Ubuntu build: $should_build_ubuntu"
        echo "Generated matrix: $matrix_targets"
        #linux/amd64

  ubuntu-22:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        arch: [linux/amd64, linux/ppc64le]

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build ${{ matrix.arch }}
        run: |
          docker run --platform ${{ matrix.arch }} --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace ${{ env.ubuntu_image }} /bin/sh -c '
            set -e
            export DEBIAN_FRONTEND=noninteractive
            sed -i "s|archive.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list
            sed -i "s|security.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list

            apt update
            apt install -y build-essential libsdl2-dev cmake git
            cmake -B build
            cmake --build build --config Release -j $(nproc)'

  ubuntu-22-arm64:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        arch: [linux/arm64]

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build ${{ matrix.arch }}
        run: |
          docker run --platform ${{ matrix.arch }} --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace ${{ env.ubuntu_image }} /bin/sh -c '
            set -e
            export DEBIAN_FRONTEND=noninteractive
            sed -i "s|archive.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list
            sed -i "s|security.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list

            apt update
            apt install -y build-essential libsdl2-dev cmake git
            cmake -B build -DGGML_NATIVE=OFF -DGGML_CPU_ARM_ARCH=armv8-a
            cmake --build build --config Release -j $(nproc)'

  ubuntu-22-arm-v7:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        arch: [linux/arm/v7]

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build ${{ matrix.arch }}
        run: |
          docker run --platform ${{ matrix.arch }} --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace ${{ env.ubuntu_image }} /bin/sh -c '
            set -e
            export DEBIAN_FRONTEND=noninteractive
            sed -i "s|archive.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list
            sed -i "s|security.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list

            apt update
            apt install -y build-essential libsdl2-dev cmake git
            cmake -B build -DGGML_NATIVE=OFF -DGGML_CPU_ARM_ARCH=armv7-a+fp
            cmake --build build --config Release -j $(nproc)'

  macOS-latest:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: macOS-latest

    strategy:
      matrix:
        destination: ['generic/platform=macOS', 'generic/platform=iOS', 'generic/platform=tvOS']

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.16
        with:
          key: macOS-latest-swift
          evict-old-files: 1d

      - name: Dependencies
        run: |
          brew update
          cmake --version
          brew install sdl2

      - name: Build
        run: |
          sysctl -a
          cmake -B build -G Xcode \
            -DGGML_METAL_USE_BF16=ON \
            -DGGML_METAL_EMBED_LIBRARY=ON \
            -DWHISPER_BUILD_EXAMPLES=OFF \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64"
          cmake --build build --config Release -j $(sysctl -n hw.logicalcpu)


#  freeBSD-latest:
#    runs-on: macos-13
#
#    steps:
#      - name: Clone
#        uses: actions/checkout@v6
#
#      - name: Build
#        uses: cross-platform-actions/action@v0.27.0
#        with:
#          operating_system: freebsd
#          version: '14.2'
#          run: |
#            sudo pkg update
#            sudo pkg install -y gmake sdl2 cmake git
#            cmake -B build
#            cmake --build build --config Release

  ubuntu-22-gcc:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        build: [Debug, Release]
        arch: [linux/amd64, linux/ppc64le]

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build ${{ matrix.arch }}
        run: |
          docker run --platform ${{ matrix.arch }} --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace ${{ env.ubuntu_image }} /bin/sh -c '
            set -e
            export DEBIAN_FRONTEND=noninteractive
            sed -i "s|archive.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list
            sed -i "s|security.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list

            apt update
            apt install -y build-essential cmake libsdl2-dev git
            cmake . -DWHISPER_SDL2=ON -DCMAKE_BUILD_TYPE=${{ matrix.build }}
            make
            ctest -L gh --output-on-failure'

  ubuntu-22-gcc-arm64:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        build: [Debug, Release]
        arch: [linux/arm64]

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build ${{ matrix.arch }}
        run: |
          docker run --platform ${{ matrix.arch }} --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace ${{ env.ubuntu_image }} /bin/sh -c '
            set -e
            export DEBIAN_FRONTEND=noninteractive
            sed -i "s|archive.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list
            sed -i "s|security.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list

            apt update
            apt install -y build-essential cmake libsdl2-dev git
            cmake . -DWHISPER_SDL2=ON -DCMAKE_BUILD_TYPE=${{ matrix.build }} -DGGML_NATIVE=OFF -DGGML_CPU_ARM_ARCH=armv8-a
            make
            ctest -L gh --output-on-failure'

  ubuntu-22-gcc-arm-v7:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        build: [Debug, Release]
        arch: [linux/arm/v7]

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build ${{ matrix.arch }}
        run: |
          docker run --platform ${{ matrix.arch }} --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace ${{ env.ubuntu_image }} /bin/sh -c '
            set -e
            export DEBIAN_FRONTEND=noninteractive
            sed -i "s|archive.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list
            sed -i "s|security.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list

            apt update
            apt install -y build-essential cmake libsdl2-dev git
            cmake . -DWHISPER_SDL2=ON -DCMAKE_BUILD_TYPE=${{ matrix.build }} -DGGML_NATIVE=OFF -DGGML_CPU_ARM_ARCH=armv7-a+fp
            make
            ctest -L gh --output-on-failure'

  ubuntu-22-clang:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        ${{fromJson(needs.prepare-matrix.outputs.ubuntu_matrix)}}

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build ${{ matrix.arch }}
        run: |
          docker run --platform ${{ matrix.arch }} --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace ${{ env.ubuntu_image }} /bin/sh -c '
            set -e
            export DEBIAN_FRONTEND=noninteractive
            sed -i "s|archive.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list
            sed -i "s|security.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list

            apt update
            apt install -y clang build-essential cmake libsdl2-dev git
            cmake . -DWHISPER_SDL2=ON -DCMAKE_BUILD_TYPE=${{ matrix.build }} -DCMAKE_CXX_COMPILER=clang++ -DCMAKE_C_COMPILER=clang
            make
            ctest -L gh --output-on-failure'
  
  ubuntu-rocm:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04
    needs: [determine-tag, prepare-matrix]
    # Check if we should run (based on the prepare-matrix output)
    strategy:
      # Uses the matrix generated in prepare-matrix (gfx_target, arch, build, sdl2)
      matrix: ${{fromJson(needs.prepare-matrix.outputs.ubuntu_matrix)}}
      fail-fast: false
    outputs:
      rocm_version: ${{ steps.set-outputs.outputs.rocm_version }}

    steps:
      - name: Free disk space
        run: curl -fsSL https://raw.githubusercontent.com/kou/arrow/e49d8ae15583ceff03237571569099a6ad62be32/ci/scripts/util_free_space.sh | bash

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install build dependencies
        run: |
          sudo apt update
          sudo apt install -y cmake ninja-build unzip curl build-essential libsdl2-dev git patchelf

      - name: Download and extract ROCm directly to /opt/rocm
        run: |
          # Determine ROCm version to use
          rocm_version="${{ env.ROCM_VERSION }}"
          current_target="${{ matrix.gfx_target }}"
          
          # Add appropriate suffixes for different GPU targets
          s3_target="$current_target"
          if [ "$current_target" = "gfx110X" ]; then
            s3_target="${current_target}-dgpu"
            echo "Using S3 target with -dgpu suffix: $s3_target"
          elif [ "$current_target" = "gfx120X" ]; then
            s3_target="${current_target}-all"
            echo "Using S3 target with -all suffix: $s3_target"
          fi
          
          if [ "$rocm_version" = "latest" ]; then
            echo "Auto-detecting latest ROCm version for target: $current_target"
            s3_response=$(curl -s "https://therock-nightly-tarball.s3.amazonaws.com/?prefix=therock-dist-linux-${s3_target}-7")
            
            # Extract all files
            files=$(echo "$s3_response" | grep -oP '(?<=<Key>)[^<]*' | grep "therock-dist-linux-${s3_target}-")
            
            # Extract versions and sort them properly
            latest_file=""
            latest_major=0
            latest_minor=0
            latest_patch=0
            latest_rc=0
            latest_is_alpha=false
            
            while IFS= read -r file; do
              if [[ "$file" =~ therock-dist-linux-${s3_target}-.*?([0-9]+\.[0-9]+\.[0-9]+(a|rc)[0-9]+)\.tar\.gz ]]; then
                version="${BASH_REMATCH[1]}"
                major=$(echo "$version" | cut -d. -f1)
                minor=$(echo "$version" | cut -d. -f2)
                patch=$(echo "$version" | cut -d. -f3 | sed 's/\(a\|rc\).*//')
                rc=$(echo "$version" | sed 's/.*\(a\|rc\)//')
                is_alpha=false
                if [[ "$version" =~ a ]]; then is_alpha=true; fi
                
                is_newer=false
                if [ "$major" -gt "$latest_major" ]; then is_newer=true;
                elif [ "$major" -eq "$latest_major" ] && [ "$minor" -gt "$latest_minor" ]; then is_newer=true;
                elif [ "$major" -eq "$latest_major" ] && [ "$minor" -eq "$latest_minor" ] && [ "$patch" -gt "$latest_patch" ]; then is_newer=true;
                elif [ "$major" -eq "$latest_major" ] && [ "$minor" -eq "$latest_minor" ] && [ "$patch" -eq "$latest_patch" ]; then
                  if [ "$is_alpha" = true ] && [ "$latest_is_alpha" = false ]; then is_newer=true;
                  elif [ "$is_alpha" = "$latest_is_alpha" ] && [ "$rc" -gt "$latest_rc" ]; then is_newer=true;
                  fi
                fi
                
                if [ "$is_newer" = true ]; then
                  latest_file="$file"
                  latest_major="$major"
                  latest_minor="$minor"
                  latest_patch="$patch"
                  latest_rc="$rc"
                  latest_is_alpha="$is_alpha"
                fi
              fi
            done <<< "$files"
            
            echo "Found latest file: $latest_file"
            
            if [[ "$latest_file" =~ therock-dist-linux-${s3_target}-.*?([0-9]+\.[0-9]+\.[0-9]+(a|rc)[0-9]+)\.tar\.gz ]]; then
              rocm_version="${BASH_REMATCH[1]}"
              echo "Detected latest ROCm version: $rocm_version"
            else
              echo "Failed to extract ROCm version from latest file: $latest_file"
              exit 1
            fi
            
            rocm_url="https://therock-nightly-tarball.s3.amazonaws.com/$latest_file"
          else
            rocm_url="https://therock-nightly-tarball.s3.amazonaws.com/therock-dist-linux-${s3_target}-${rocm_version}.tar.gz"
          fi
          
          echo "DETECTED_ROCM_VERSION=$rocm_version" >> $GITHUB_ENV
          
          # Create directory and stream extraction
          sudo mkdir -p /opt/rocm
          curl -sL "$rocm_url" | sudo tar --use-compress-program=gzip -xf - -C /opt/rocm --strip-components=1

      - name: Set ROCm environment variables
        run: |
          echo "HIP_PATH=/opt/rocm" >> $GITHUB_ENV
          echo "ROCM_PATH=/opt/rocm" >> $GITHUB_ENV
          echo "HIP_PLATFORM=amd" >> $GITHUB_ENV
          echo "/opt/rocm/bin:/opt/rocm/llvm/bin:$PATH" >> $GITHUB_PATH
      
      - name: Find ROCm bitcode path
        run: |
          # Dynamically find the directory containing device libraries (amdgcn/bitcode)
          BITCODE_PATH=$(find /opt/rocm -type d -name bitcode -print -quit)
          
          if [ -z "$BITCODE_PATH" ]; then
            echo "::error::Could not find 'bitcode' directory in /opt/rocm"
            find /opt/rocm -maxdepth 5
            exit 1
          fi
          
          echo "Found bitcode at: $BITCODE_PATH"
          echo "ROCM_BITCODE_PATH=$BITCODE_PATH" >> $GITHUB_ENV

      - name: Configure CMake
        run: |

          # Map GPU targets
          current_target="${{ matrix.gfx_target }}"
          echo "Input target: $current_target"
          
          if [ "$current_target" = "gfx110X" ]; then
            mapped_target="gfx1100;gfx1101;gfx1102"
          elif [ "$current_target" = "gfx1151" ]; then
            mapped_target="gfx1151"
          elif [ "$current_target" = "gfx1150" ]; then
            mapped_target="gfx1150"
          elif [ "$current_target" = "gfx120X" ]; then
            mapped_target="gfx1200;gfx1201"
          else
            mapped_target="$current_target"
          fi
          echo "Mapped target: $mapped_target"

          cmake -S . -B build -G Ninja \
            -DCMAKE_C_COMPILER=/opt/rocm/llvm/bin/clang \
            -DCMAKE_CXX_COMPILER=/opt/rocm/llvm/bin/clang++ \
            -DCMAKE_HIP_FLAGS="--rocm-path=/opt/rocm --rocm-device-lib-path=${{ env.ROCM_BITCODE_PATH }}" \
            -DCMAKE_PREFIX_PATH=/opt/rocm \
            -DCMAKE_BUILD_TYPE=${{ matrix.build }} \
            -DGPU_TARGETS="$mapped_target" \
            -DBUILD_SHARED_LIBS=ON \
            -DGGML_HIP=ON \
            -DGGML_ROCM=1 \
            -DWHISPER_SDL2=${{ matrix.sdl2 }}

      - name: Build
        run: cmake --build build --config ${{ matrix.build }} -j $(nproc)

      # Copy Backend ROCm Folders ---
      - name: Copy ROCm core and sysdep libs to build directory
        run: |
          build_bin_path="build/bin"
          rocm_bin_path="/opt/rocm/bin"
          rocm_lib_path="/opt/rocm/lib"
          rocm_sysdeps_path="/opt/rocm/lib/rocm_sysdeps/lib"
          
          # Ensure build directory exists
          mkdir -p "$build_bin_path"

          # Copy rocblas/library folder
          rocblas_lib_path="$rocm_lib_path/rocblas/library"
          if [ -d "$rocblas_lib_path" ]; then
            dest_rocblas_path="$build_bin_path/rocblas/library"
            mkdir -p "$(dirname "$dest_rocblas_path")"
            cp -r "$rocblas_lib_path" "$(dirname "$dest_rocblas_path")/"
            echo "Copied: rocblas/library"
          fi

          # Copy hipblaslt/library folder
          hipblaslt_lib_path="$rocm_lib_path/hipblaslt/library"
          if [ -d "$hipblaslt_lib_path" ]; then
            dest_hipblaslt_path="$build_bin_path/hipblaslt/library"
            mkdir -p "$(dirname "$dest_hipblaslt_path")"
            cp -r "$hipblaslt_lib_path" "$(dirname "$dest_hipblaslt_path")/"
            echo "Copied: hipblaslt/library"
          fi
 
          # Copy standard ROCm shared libraries
          echo "Copying core shared libraries..."
          cp -v $rocm_lib_path/libhipblas.so* "$build_bin_path/" 2>/dev/null || true
          cp -v $rocm_lib_path/librocblas.so* "$build_bin_path/" 2>/dev/null || true
          cp -v $rocm_lib_path/libamdhip64.so* "$build_bin_path/" 2>/dev/null || true
          cp -v $rocm_lib_path/librocsolver.so* "$build_bin_path/" 2>/dev/null || true
          cp -v $rocm_lib_path/libroctx64.so* "$build_bin_path/" 2>/dev/null || true
          cp -v $rocm_lib_path/libhipblaslt.so* "$build_bin_path/" 2>/dev/null || true
          cp -v $rocm_lib_path/libamd_comgr.so* "$build_bin_path/" 2>/dev/null || true
          cp -v $rocm_lib_path/libhsa-runtime64.so* "$build_bin_path/" 2>/dev/null || true
          
          # Copy LLVM runtime libs
          cp -v $rocm_lib_path/llvm/lib/libLLVM.so* "$build_bin_path/" 2>/dev/null || true
          cp -v $rocm_lib_path/llvm/lib/libclang-cpp.so* "$build_bin_path/" 2>/dev/null || true

          if [ -d "$rocm_sysdeps_path" ]; then
            echo "Copying sysdep libraries from $rocm_sysdeps_path..."
            # Using a broad wildcard ensures we grab elf.so.1, drm.so.2, numa.so.1, etc.
            cp -v $rocm_sysdeps_path/librocm_sysdeps_*.so* "$build_bin_path/"
          fi

      - name: Bundle Linked Libraries
        run: |
          build_bin="build/bin"
          echo "Scanning dependencies for whisper-cli..."

          ldd "$build_bin/whisper-cli" | grep "=> /" | while read -r line; do
              
              soname=$(echo "$line" | awk '{print $1}')
              path=$(echo "$line" | awk '{print $3}')
              
              if [[ "$soname" =~ ^(libc\.so|libm\.so|libdl\.so|librt\.so|libpthread\.so|libstdc\+\+|libgcc_s|ld-linux) ]]; then
                  continue
              fi
              echo "Bundling: $soname"
              echo "  Source: $path"
              cp -L "$path" "$build_bin/$soname"
          done
          chmod +x "$build_bin"/*.so*

      - name: Set RPATH for portable distribution
        run: |
          cd build/bin
          # Set RPATH to $ORIGIN so the binary looks for .so files in its own directory
          # wildcards catch whisper-cli, whisper-bench, etc., plus shared libs
          for file in *.so* whisper-*; do
            if [ -f "$file" ] && [ ! -L "$file" ]; then
               # Only patch ELF files (executables and shared objects)
               if file "$file" | grep -q "ELF"; then
                 patchelf --set-rpath '$ORIGIN' "$file" 2>/dev/null || true
                 echo "Patched RPATH for $file"
               fi
            fi
          done

      - name: Pack bin artifacts
        run: |
          cd build/bin
          SAFE_ARCH=$(echo "${{ matrix.arch }}" | tr '/' '-')
          
          # 1. Save SAFE_ARCH to GITHUB_ENV so the next step can use it
          echo "SAFE_ARCH=$SAFE_ARCH" >> $GITHUB_ENV
          
          # Include target in filename (e.g., whisper-bin-gfx1100-linux-amd64.zip)
          zip -r ../../whisper-bin-${{ matrix.gfx_target }}-${SAFE_ARCH}.zip .

      - name: Upload binaries
        if: matrix.sdl2 == 'ON' && needs.determine-tag.outputs.should_release
        uses: actions/upload-artifact@v4
        with:
          name: whisper-bin-${{ matrix.gfx_target }}-${{ env.SAFE_ARCH }}
          path: whisper-bin-*.zip

  ubuntu-22-gcc-sanitized:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        sanitizer: [ADDRESS, THREAD, UNDEFINED]
        arch: [linux/amd64]

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Build ${{ matrix.arch }}
        run: |
          docker run --platform ${{ matrix.arch }} --rm \
            -v ${{ github.workspace }}:/workspace \
            -w /workspace ${{ env.ubuntu_image }} /bin/sh -c '
            set -e
            export DEBIAN_FRONTEND=noninteractive
            sed -i "s|archive.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list
            sed -i "s|security.ubuntu.com|mirrors.kernel.org|g" /etc/apt/sources.list

            apt update
            apt install -y build-essential cmake git
            cmake . -DCMAKE_BUILD_TYPE=Debug \
              -DWHISPER_SANITIZE_${{ matrix.sanitizer }}=ON \
              -DGGML_OPENMP=OFF
            make
            ctest -L gh --output-on-failure'

  ubuntu-22-cmake-sycl:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        dwhisper_sycl: [ON]
        dcmake_c_compiler: [icx]
        dcmake_cxx_compiler: [icpx]
        arch: [linux/amd64, linux/arm64, linux/arm/v7, linux/ppc64le]

    continue-on-error: true

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: add oneAPI to apt
        shell: bash
        run: |
          cd /tmp
          wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
          sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
          rm GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
          sudo add-apt-repository "deb https://apt.repos.intel.com/oneapi all main"

      - name: install oneAPI dpcpp compiler
        shell: bash
        run: |
          sudo apt update
          sudo apt install intel-oneapi-compiler-dpcpp-cpp git

      - name: install oneAPI MKL library
        shell: bash
        run: |
          sudo apt install intel-oneapi-mkl-devel git

      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: Build
        id: cmake_build
        run: |
          source /opt/intel/oneapi/setvars.sh
          mkdir build
          cd build
          cmake -DGGML_SYCL=ON -DCMAKE_C_COMPILER=icx -DCMAKE_CXX_COMPILER=icpx ..
          cmake --build . --config Release -j $(nproc)

  ubuntu-22-cmake-sycl-fp16:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      fail-fast: false
      matrix:
        dwhisper_sycl: [ON]
        dcmake_c_compiler: [icx]
        dcmake_cxx_compiler: [icpx]
        arch: [linux/amd64, linux/arm64, linux/arm/v7, linux/ppc64le]

    continue-on-error: true

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: add oneAPI to apt
        shell: bash
        run: |
          cd /tmp
          wget https://apt.repos.intel.com/intel-gpg-keys/GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
          sudo apt-key add GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
          rm GPG-PUB-KEY-INTEL-SW-PRODUCTS.PUB
          sudo add-apt-repository "deb https://apt.repos.intel.com/oneapi all main"

      - name: install oneAPI dpcpp compiler
        shell: bash
        run: |
          sudo apt update
          sudo apt install intel-oneapi-compiler-dpcpp-cpp git

      - name: install oneAPI MKL library
        shell: bash
        run: |
          sudo apt install intel-oneapi-mkl-devel

      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: Build
        id: cmake_build
        run: |
          source /opt/intel/oneapi/setvars.sh
          mkdir build
          cd build
          cmake -DGGML_SYCL_F16=ON -DCMAKE_C_COMPILER=icx -DCMAKE_CXX_COMPILER=icpx ..
          cmake --build . --config Release -j $(nproc)

  windows-msys2:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: windows-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - { sys: UCRT64,  env: ucrt-x86_64,  build: Release }
          - { sys: CLANG64, env: clang-x86_64, build: Release }

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Setup ${{ matrix.sys }}
        uses: msys2/setup-msys2@v2
        with:
          update: true
          msystem: ${{matrix.sys}}
          install: >-
            base-devel
            git
            mingw-w64-${{matrix.env}}-toolchain
            mingw-w64-${{matrix.env}}-cmake
            mingw-w64-${{matrix.env}}-SDL2
            mingw-w64-${{matrix.env}}-openblas

      - name: Build using CMake
        shell: msys2 {0}
        run: |
            cmake -B build -DWHISPER_SDL2=ON
            cmake --build build --config ${{ matrix.build }} -j $(nproc)

      - name: Clean after building using CMake
        shell: msys2 {0}
        run: |
            rm -rf build

      - name: Build using CMake w/ OpenBLAS
        shell: msys2 {0}
        run: |
            cmake -B build -DGGML_BLAS=ON -DGGML_BLAS_VENDOR=OpenBLAS
            cmake --build build --config ${{ matrix.build }} -j $(nproc)

  windows:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: windows-latest
    needs: determine-tag

    strategy:
      matrix:
        build: [Release]
        arch: [Win32, x64]
        sdl2: [ON]
        include:
          - arch: Win32
            s2arc: x86
            jnaPath: win32-x86
          - arch: x64
            s2arc: x64
            jnaPath: win32-x86-64
          - sdl2: ON
            s2ver: 2.28.5

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Add msbuild to PATH
        uses: microsoft/setup-msbuild@v2

      - name: Fetch SDL2 and set SDL2_DIR
        if: matrix.sdl2 == 'ON'
        run: |
          C:/msys64/usr/bin/wget.exe -qO sdl2.zip https://github.com/libsdl-org/SDL/releases/download/release-${{ matrix.s2ver }}/SDL2-devel-${{ matrix.s2ver }}-VC.zip
          7z x sdl2.zip
          echo "SDL2_DIR=$env:GITHUB_WORKSPACE/SDL2-${{ matrix.s2ver }}/cmake" >> $env:GITHUB_ENV

      - name: Configure
        run: >
          cmake -S . -B ./build -A ${{ matrix.arch }}
          -DCMAKE_BUILD_TYPE=${{ matrix.build }}
          -DBUILD_SHARED_LIBS=ON
          -DWHISPER_SDL2=${{ matrix.sdl2 }}

      - name: Build
        run: |
          cd ./build
          msbuild ALL_BUILD.vcxproj -t:build -p:configuration=${{ matrix.build }} -p:platform=${{ matrix.arch }}

      - name: Copy SDL2.dll
        if: matrix.sdl2 == 'ON'
        run: copy "$env:SDL2_DIR/../lib/${{ matrix.s2arc }}/SDL2.dll" build/bin/${{ matrix.build }}

      - name: Upload SDL2.dll
        if: matrix.sdl2 == 'ON'
        uses: actions/upload-artifact@v6
        with:
          name: ${{ matrix.s2arc }}_SDL2.dll
          path: build/bin/${{ matrix.build }}/SDL2.dll

      - name: Upload whisper dll
        uses: actions/upload-artifact@v6
        with:
          name: whisper_${{ matrix.arch }}.dll
          path: build/bin/${{ matrix.build }}/whisper.dll

      - name: Upload ggml dll
        uses: actions/upload-artifact@v6
        with:
          name: ggml_${{ matrix.arch }}.dll
          path: build/bin/${{ matrix.build }}/ggml.dll

      - name: Upload ggml base dll
        uses: actions/upload-artifact@v6
        with:
          name: ggml_base_${{ matrix.arch }}.dll
          path: build/bin/${{ matrix.build }}/ggml-base.dll

      - name: Upload ggml cpu dll
        uses: actions/upload-artifact@v6
        with:
          name: ggml_cpu_${{ matrix.arch }}.dll
          path: build/bin/${{ matrix.build }}/ggml-cpu.dll

      - name: Pack bin artifacts
        shell: pwsh
        run: |
              Compress-Archive -Path "build/bin/${{ matrix.build }}" -DestinationPath "whisper-bin-${{ matrix.arch }}.zip"

      - name: Upload binaries
        if: matrix.sdl2 == 'ON' && ${{ needs.determine-tag.outputs.should_release }}
        uses: actions/upload-artifact@v6
        with:
          name: whisper-bin-${{ matrix.arch }}.zip
          path: whisper-bin-${{ matrix.arch }}.zip

  windows-blas:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: windows-latest

    strategy:
      matrix:
        build: [Release]
        arch: [Win32, x64]
        blas: [ON]
        sdl2: [ON]
        blasver: [0.3.29]
        include:
          - arch: Win32
            s2arc: x86
            blasfile: x86
          - arch: x64
            s2arc: x64
            blasfile: x64_64
          - sdl2: ON
            s2ver: 2.28.5

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Export GitHub Actions cache environment variables
        uses: actions/github-script@v8
        with:
          script: |
            core.exportVariable('ACTIONS_CACHE_URL', process.env.ACTIONS_CACHE_URL || '');
            core.exportVariable('ACTIONS_RUNTIME_TOKEN', process.env.ACTIONS_RUNTIME_TOKEN || '');

      - name: Add msbuild to PATH
        uses: microsoft/setup-msbuild@v2

      - name: Install OpenBLAS and pkgconfiglite
        if: matrix.blas == 'ON'
        run: |
          Invoke-WebRequest "https://github.com/OpenMathLib/OpenBLAS/releases/download/v${{matrix.blasver}}/OpenBLAS-${{matrix.blasver}}_${{matrix.blasfile}}.zip" -OutFile "OpenBLAS-${{matrix.blasver}}.zip"
          Expand-Archive "OpenBLAS-${{matrix.blasver}}.zip" -DestinationPath "OpenBLAS-${{matrix.blasver}}"
          choco install pkgconfiglite

      - name: Fetch SDL2 and set SDL2_DIR
        if: matrix.sdl2 == 'ON'
        run: |
          C:/msys64/usr/bin/wget.exe -qO sdl2.zip https://github.com/libsdl-org/SDL/releases/download/release-${{ matrix.s2ver }}/SDL2-devel-${{ matrix.s2ver }}-VC.zip
          7z x sdl2.zip
          echo "SDL2_DIR=$env:GITHUB_WORKSPACE/SDL2-${{ matrix.s2ver }}/cmake" >> $env:GITHUB_ENV

      - name: Configure
        run: >
          cmake -S . -B ./build -A ${{ matrix.arch }}
          -DCMAKE_TOOLCHAIN_FILE="$env:VCPKG_INSTALLATION_ROOT/scripts/buildsystems/vcpkg.cmake"
          -DCMAKE_BUILD_TYPE=${{ matrix.build }}
          -DGGML_BLAS=${{ matrix.blas }}
          -DGGML_BLAS_VENDOR=OpenBLAS
          -DBLAS_LIBRARIES="$env:GITHUB_WORKSPACE/OpenBLAS-${{matrix.blasver}}/lib/libopenblas.lib"
          -DBLAS_INCLUDE_DIRS="$env:GITHUB_WORKSPACE/OpenBLAS-${{matrix.blasver}}/include"
          -DWHISPER_SDL2=${{ matrix.sdl2 }}

      - name: Build
        run: |
          cd ./build
          msbuild ALL_BUILD.vcxproj -t:build -p:configuration=${{ matrix.build }} -p:platform=${{ matrix.arch }}

      - name: Copy openblas.dll
        if: matrix.blas == 'ON'
        run: copy "$env:GITHUB_WORKSPACE/OpenBLAS-${{matrix.blasver}}/bin/libopenblas.dll" build/bin/${{ matrix.build }}

      - name: Copy SDL2.dll
        if: matrix.sdl2 == 'ON'
        run: copy "$env:SDL2_DIR/../lib/${{ matrix.s2arc }}/SDL2.dll" build/bin/${{ matrix.build }}

      - name: Pack bin artifacts
        shell: pwsh
        run: |
              Compress-Archive -Path "build/bin/${{ matrix.build }}" -DestinationPath "whisper-blas-bin-${{ matrix.arch }}.zip"

      - name: Upload binaries
        if: matrix.blas == 'ON' && matrix.sdl2 == 'ON' && ${{ needs.determine-tag.outputs.should_release }}
        uses: actions/upload-artifact@v6
        with:
          name: whisper-blas-bin-${{ matrix.arch }}.zip
          path: whisper-blas-bin-${{ matrix.arch }}.zip

  windows-cublas:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: windows-2022
    needs: determine-tag
    strategy:
      fail-fast: false
      matrix:
        build: [Release]
        arch: [x64]
        cublas: [ON]
        sdl2: [ON]
        cuda-toolkit: [12.4.0, 11.8.0]
        include:
          - arch: x64
            sdl2: ON
            sdl2_ver: 2.28.5
    steps:
      - name: Clone repository
        uses: actions/checkout@v6

      - name: Install Ninja
        id: install_ninja
        run: |
          choco install ninja

      - name: Install ccache
        uses: hendrikmuhs/ccache-action@v1.2.16
        with:
          key: ${{ github.job }}-${{ matrix.cuda-toolkit }}-${{ matrix.build }}
          variant: sccache
          evict-old-files: 5d

      - name: Install Cuda Toolkit 11.8.0
        if: ${{ matrix.cuda-toolkit == '11.8.0' }}
        run: |
          $CUDA_VERSION = ${{ matrix.cuda-toolkit }}
          $CUDA_TOOLKIT_DIR = "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v$CUDA_VERSION"
          $CUDA_DOWNLOAD = "https://developer.download.nvidia.com/compute/cuda/redist"

          # Components versions
          $CUDART_VER = "11.8.89"
          $NVCC_VER   = "11.8.89"
          $NVRTC_VER  = "11.8.89"
          $CUBLAS_VER = "11.8.1.74"
          $NVTX_VER   = "11.8.86"
          $VS_VER     = "11.8.86"
          $NVPROF_VER = "11.8.87"
          $CCCL_VER   = "11.8.89"

          # Create the directory where the CUDA Toolkit will be installed
          mkdir -p $CUDA_TOOLKIT_DIR

          # Install unzip to extract the downloaded files
          choco install unzip -y

          # Download all the required components
          curl -O "$CUDA_DOWNLOAD/cuda_cudart/windows-x86_64/cuda_cudart-windows-x86_64-${CUDART_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_nvcc/windows-x86_64/cuda_nvcc-windows-x86_64-${NVCC_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_nvrtc/windows-x86_64/cuda_nvrtc-windows-x86_64-${NVRTC_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/libcublas/windows-x86_64/libcublas-windows-x86_64-${CUBLAS_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_nvtx/windows-x86_64/cuda_nvtx-windows-x86_64-${NVTX_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/visual_studio_integration/windows-x86_64/visual_studio_integration-windows-x86_64-${VS_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_nvprof/windows-x86_64/cuda_nvprof-windows-x86_64-${NVPROF_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_cccl/windows-x86_64/cuda_cccl-windows-x86_64-${CCCL_VER}-archive.zip"

          # Extract all the downloaded files to the CUDA Toolkit directory
          unzip '*.zip' -d $CUDA_TOOLKIT_DIR

          # Copy all the extracted files to the main CUDA Toolkit directory
          xcopy "$CUDA_TOOLKIT_DIR\cuda_cudart-windows-x86_64-${CUDART_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_nvcc-windows-x86_64-${NVCC_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_nvrtc-windows-x86_64-${NVRTC_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\libcublas-windows-x86_64-${CUBLAS_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_nvtx-windows-x86_64-${NVTX_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_nvprof-windows-x86_64-${NVPROF_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_cccl-windows-x86_64-${CCCL_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\visual_studio_integration-windows-x86_64-${VS_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y

          # Visual Studio integration
          xcopy "$CUDA_TOOLKIT_DIR\visual_studio_integration-windows-x86_64-${VS_VER}-archive\visual_studio_integration\MSBuildExtensions\*" "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Microsoft\VC\v170\BuildCustomizations" /E /I /H /Y

          # Set environment variables
          echo "$CUDA_TOOLKIT_DIR\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          echo "$CUDA_TOOLKIT_DIR\libnvvp" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          echo "CUDA_PATH=$CUDA_TOOLKIT_DIR" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          echo "CUDA_PATH_V11_8=$CUDA_TOOLKIT_DIR" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        
      - name: Install Cuda Toolkit 12.4.0
        if: ${{ matrix.cuda-toolkit == '12.4.0' }}
        run: |
          $CUDA_VERSION = ${{ matrix.cuda-toolkit }}
          $CUDA_TOOLKIT_DIR = "C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v$CUDA_VERSION"
          $CUDA_DOWNLOAD = "https://developer.download.nvidia.com/compute/cuda/redist"

          # Components versions
          $CUDART_VER   = "12.4.127"
          $NVCC_VER     = "12.4.131"
          $NVRTC_VER    = "12.4.127"
          $CUBLAS_VER   = "12.4.5.8"
          $NVTX_VER     = "12.4.127"
          $PROFILER_VER = "12.4.127"
          $VS_VER       = "12.4.127"
          $NVPROF_VER   = "12.4.128"
          $CCCL_VER     = "12.4.127"

          # Create the directory where the CUDA Toolkit will be installed
          mkdir -p $CUDA_TOOLKIT_DIR

          # Install unzip to extract the downloaded files
          choco install unzip -y

          # Download all the required components
          curl -O "$CUDA_DOWNLOAD/cuda_cudart/windows-x86_64/cuda_cudart-windows-x86_64-${CUDART_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_nvcc/windows-x86_64/cuda_nvcc-windows-x86_64-${NVCC_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_nvrtc/windows-x86_64/cuda_nvrtc-windows-x86_64-${NVRTC_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/libcublas/windows-x86_64/libcublas-windows-x86_64-${CUBLAS_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_nvtx/windows-x86_64/cuda_nvtx-windows-x86_64-${NVTX_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_profiler_api/windows-x86_64/cuda_profiler_api-windows-x86_64-${PROFILER_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/visual_studio_integration/windows-x86_64/visual_studio_integration-windows-x86_64-${VS_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_nvprof/windows-x86_64/cuda_nvprof-windows-x86_64-${NVPROF_VER}-archive.zip"
          curl -O "$CUDA_DOWNLOAD/cuda_cccl/windows-x86_64/cuda_cccl-windows-x86_64-${CCCL_VER}-archive.zip"

          # Extract all the downloaded files to the CUDA Toolkit directory
          unzip -q '*.zip' -d $CUDA_TOOLKIT_DIR

          # Copy all the extracted files to the main CUDA Toolkit directory
          xcopy "$CUDA_TOOLKIT_DIR\cuda_cudart-windows-x86_64-${CUDART_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_nvcc-windows-x86_64-${NVCC_VER}-archive\*"     "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_nvrtc-windows-x86_64-${NVRTC_VER}-archive\*"   "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\libcublas-windows-x86_64-${CUBLAS_VER}-archive\*"   "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_nvtx-windows-x86_64-${NVTX_VER}-archive\*"     "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_nvprof-windows-x86_64-${NVPROF_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_cccl-windows-x86_64-${CCCL_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\cuda_profiler_api-windows-x86_64-${PROFILER_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y
          xcopy "$CUDA_TOOLKIT_DIR\visual_studio_integration-windows-x86_64-${VS_VER}-archive\*" "$CUDA_TOOLKIT_DIR" /E /I /H /Y

          # Visual Studio integration
          xcopy "$CUDA_TOOLKIT_DIR\visual_studio_integration-windows-x86_64-${VS_VER}-archive\visual_studio_integration\MSBuildExtensions\*" "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Microsoft\VC\v170\BuildCustomizations" /E /I /H /Y

          # Set environment variables
          echo "$CUDA_TOOLKIT_DIR\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          echo "$CUDA_TOOLKIT_DIR\libnvvp" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          echo "CUDA_PATH=$CUDA_TOOLKIT_DIR" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
          echo "CUDA_PATH_V12_2=$CUDA_TOOLKIT_DIR" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8

      - name: Add msbuild to PATH
        uses: microsoft/setup-msbuild@v2

      - name: Install 7-Zip
        run: choco install 7zip -y

      - name: Fetch SDL2 and set SDL2_DIR
        if: matrix.sdl2 == 'ON'
        run: |
          Invoke-WebRequest -Uri https://github.com/libsdl-org/SDL/releases/download/release-${{ matrix.sdl2_ver }}/SDL2-devel-${{ matrix.sdl2_ver }}-VC.zip -OutFile sdl2.zip
          7z x sdl2.zip
          echo "SDL2_DIR=${{ github.workspace }}\SDL2-${{ matrix.sdl2_ver }}\cmake" | Out-File -FilePath $env:GITHUB_ENV -Append
          echo "${{ github.workspace }}\SDL2-${{ matrix.sdl2_ver }}\cmake" > SDL2_PATH.txt

      - name: Install cmake
        run: choco install cmake

      - name: Build Project
        shell: cmd
        run: |
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
          cmake --version
          where cmake
          if "${{ matrix.cuda-toolkit }}" == "11.8.0" (
            set CUDA_FLAGS=-allow-unsupported-compiler -D_ALLOW_COMPILER_AND_STL_VERSION_MISMATCH -D_DISABLE_CONSTEXPR_MUTEX_CONSTRUCTOR
          ) else (
            set CUDA_FLAGS=
          )
          cmake -S . -B build -G "Ninja Multi-Config" ^
            -DCMAKE_BUILD_TYPE=${{ matrix.build }} ^
            -DGGML_CUDA=${{ matrix.cublas }} ^
            -DWHISPER_SDL2=${{ matrix.sdl2 }} ^
            -DSDL2_DIR="%SDL2_DIR%" ^
            -DCMAKE_POLICY_VERSION_MINIMUM=3.5 ^
            -DCMAKE_CUDA_FLAGS="%CUDA_FLAGS%"
          set /A NINJA_JOBS=%NUMBER_OF_PROCESSORS%-1
          cmake --build build --config ${{ matrix.build }} -j %NUMBER_OF_PROCESSORS%

      - name: Check sccache status after build
        run: |
          sccache --show-stats

      - name: Copy CUDA DLLs
        run: |
          Get-ChildItem "$env:CUDA_PATH\bin\" -Filter "*.dll" |
          Copy-Item -Destination "build/bin/${{ matrix.build }}"

      - name: Copy SDL2.dll
        if: matrix.sdl2 == 'ON'
        run: copy "$env:SDL2_DIR/../lib/${{ matrix.arch }}/SDL2.dll" build/bin/${{ matrix.build }}

      - name: Pack bin artifacts
        shell: pwsh
        run: |
              Compress-Archive -Path "build/bin/${{ matrix.build }}" -DestinationPath "whisper-cublas-${{ matrix.cuda-toolkit }}-bin-${{ matrix.arch }}.zip"

      - name: Upload binaries
        if: ${{ needs.determine-tag.outputs.should_release }}
        uses: actions/upload-artifact@v6
        with:
          name: whisper-cublas-${{ matrix.cuda-toolkit }}-bin-${{ matrix.arch }}.zip
          path: whisper-cublas-${{ matrix.cuda-toolkit }}-bin-${{ matrix.arch }}.zip
  
  windows-rocm:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: windows-latest
    needs: [determine-tag, prepare-matrix]
    strategy:
      matrix: ${{fromJson(needs.prepare-matrix.outputs.windows_matrix)}}
      fail-fast: false
    outputs:
      rocm_version: ${{ steps.set-outputs.outputs.rocm_version }}

    steps:
      - name: Clone
        uses: actions/checkout@v4

      - name: Install Ninja
        run: choco install ninja

      - name: Fetch SDL2 and Patch Header (Robust)
        if: matrix.sdl2 == 'ON'
        shell: pwsh
        run: |
          $sdlVer = "${{ matrix.s2ver }}"
          $url = "https://github.com/libsdl-org/SDL/releases/download/release-$sdlVer/SDL2-devel-$sdlVer-VC.zip"
          
          Write-Host "Downloading SDL2 from $url..."
          Invoke-WebRequest -Uri $url -OutFile "sdl2.zip"
          
          Write-Host "Extracting SDL2..."
          7z x sdl2.zip
          
          # 1. Locate CMake config dynamically
          $cmakeFile = Get-ChildItem -Path . -Recurse -Filter "sdl2-config.cmake" | Select-Object -First 1
          if ($cmakeFile) {
            $cmakeDir = $cmakeFile.DirectoryName
            Write-Host "Found SDL2 CMake dir at: $cmakeDir"
            echo "SDL2_DIR=$cmakeDir" >> $env:GITHUB_ENV
          } else {
            Write-Error "FATAL: Could not find sdl2-config.cmake inside extracted files!"
            exit 1
          }

          # 2. Find and Patch SDL_endian.h recursively
          Write-Host "Searching for SDL_endian.h..."
          $headerFile = Get-ChildItem -Path . -Recurse -Filter "SDL_endian.h" | Select-Object -First 1
          
          if ($headerFile) {
             Write-Host "Found header at: $($headerFile.FullName)"
             $content = Get-Content $headerFile.FullName -Raw
             
             # The Fix: Comment out the extern declaration
             if ($content -match 'extern void _m_prefetch') {
                $content = $content -replace 'extern void _m_prefetch\(void \*__P\);', '// extern void _m_prefetch(void *__P);'
                Set-Content -Path $headerFile.FullName -Value $content
                Write-Host "SUCCESS: Patched _m_prefetch in SDL_endian.h"
             } else {
                Write-Host "WARNING: _m_prefetch string not found. It might be a different SDL version or already patched."
             }
          } else {
             # Debug output if file is missing
             Write-Host "Listing root directories:"
             Get-ChildItem -Path . -Directory | Format-Table Name
             Write-Error "FATAL: Could not locate SDL_endian.h in the workspace."
             exit 1
          }

      - name: Download ROCm nightly tarball
        run: |
          # Determine ROCm version to use
          $rocmVersion = "${{ env.ROCM_VERSION }}"
          $currentTarget = "${{ matrix.gfx_target }}"
          
          $s3Target = $currentTarget
          if ($currentTarget -eq "gfx110X") {
            $s3Target = "$currentTarget-dgpu"
            Write-Host "Using S3 target with -dgpu suffix: $s3Target"
          } elseif ($currentTarget -eq "gfx120X") {
            $s3Target = "$currentTarget-all"
            Write-Host "Using S3 target with -all suffix: $s3Target"
          }
          
          if ($rocmVersion -eq "latest") {
            Write-Host "Auto-detecting latest ROCm version for target: $currentTarget"
            $s3Response = (Invoke-WebRequest "https://therock-nightly-tarball.s3.amazonaws.com/?prefix=therock-dist-windows-$s3Target-7").Content
            $files = $s3Response -split '<Key>' | Where-Object {$_ -match '</Key>'} | ForEach-Object { ($_ -split '</Key>')[0] }
            
            $versionFiles = @()
            foreach ($file in $files) {
              if ($file -match "therock-dist-windows-$s3Target-.*?(\d+\.\d+\.\d+(?:a|rc)\d+)\.tar\.gz") {
                $version = $matches[1]
                $versionFiles += [PSCustomObject]@{
                  File = $file
                  Version = $version
                  Major = [int]($version -split '\.')[0]
                  Minor = [int]($version -split '\.')[1]
                  Patch = [int](($version -split '\.')[2] -replace '(?:a|rc).*', '')
                  RC = [int]($version -replace '.*(?:a|rc)', '')
                  IsAlpha = $version -match 'a'
                }
              }
            }
            
            $latestFile = ($versionFiles | Sort-Object Major, Minor, Patch, @{Expression={if($_.IsAlpha){1}else{0}}}, RC | Select-Object -Last 1).File
            Write-Host "Found latest file: $latestFile"
            
            if ($latestFile -match "therock-dist-windows-$s3Target-.*?(\d+\.\d+\.\d+(?:a|rc)\d+)\.tar\.gz") {
              $rocmVersion = $matches[1]
              Write-Host "Detected latest ROCm version: $rocmVersion"
            } else {
              Write-Error "Failed to extract ROCm version from latest file: $latestFile"
              exit 1
            }
            $rocmUrl = "https://therock-nightly-tarball.s3.amazonaws.com/$latestFile"
          } else {
            $rocmUrl = "https://therock-nightly-tarball.s3.amazonaws.com/therock-dist-windows-$s3Target-$rocmVersion.tar.gz"
          }
          
          echo "DETECTED_ROCM_VERSION=$rocmVersion" >> $env:GITHUB_ENV
          Invoke-WebRequest -Uri $rocmUrl -OutFile "rocm.tar.gz"

      - name: Extract ROCm to C:\opt\rocm
        run: |
          New-Item -ItemType Directory -Force -Path "C:\opt\rocm"
          tar -xzf rocm.tar.gz -C C:\opt\rocm --strip-components=1

      - name: Configure
        shell: pwsh
        run: |
          $currentTarget = "${{ matrix.gfx_target }}"
          Write-Host "Input target: $currentTarget"

          if ($currentTarget -eq "gfx110X") {
            $mapped_target = "gfx1100;gfx1101;gfx1102"
          } elseif ($currentTarget -eq "gfx1151") {
            $mapped_target = "gfx1151"
          } elseif ($currentTarget -eq "gfx1150") {
            $mapped_target = "gfx1150"
          } elseif ($currentTarget -eq "gfx120X") {
            $mapped_target = "gfx1200;gfx1201"
          } else {
            $mapped_target = $currentTarget
          }
          Write-Host "Mapped target: $mapped_target"

          # Set up environment variables and PATH
          $env:HIP_PATH = "C:\opt\rocm"
          $env:HIP_PLATFORM = "amd"
          # Ensure bin comes before llvm\bin for consistency
          $env:PATH = "$env:HIP_PATH\bin;$env:HIP_PATH\lib\llvm\bin;$env:PATH"

          # Define CMake arguments
          $cmakeArgs = @(
            "-S", ".",
            "-B", "build",
            "-G", "Ninja Multi-Config",
            "-DGPU_TARGETS=$mapped_target",
            "-DGGML_HIP=ON",
            "-DCMAKE_C_COMPILER=$env:HIP_PATH/lib/llvm/bin/amdclang.exe",
            "-DCMAKE_CXX_COMPILER=$env:HIP_PATH/lib/llvm/bin/amdclang++.exe",
            "-DCMAKE_HIP_COMPILER=$env:HIP_PATH/lib/llvm/bin/amdclang++.exe",
            "-DCMAKE_C_FLAGS='-D__PRFCHWINTRIN_H'",
            "-DCMAKE_CXX_FLAGS='-D__PRFCHWINTRIN_H'",
            "-DCMAKE_HIP_FLAGS=--rocm-path=C:/opt/rocm",
            "-DCMAKE_PREFIX_PATH=$env:HIP_PATH",
            "-DGGML_ROCM=1",
            "-DCMAKE_BUILD_TYPE=${{ matrix.build }}",
            "-DBUILD_SHARED_LIBS=ON",
            "-DWHISPER_SDL2=${{ matrix.sdl2 }}"
          )
          # Run CMake
          cmake @cmakeArgs

      - name: Build
        shell: pwsh
        run: |
          cmake --build build --config ${{ matrix.build }} -j $env:NUMBER_OF_PROCESSORS

      - name: Copy ROCm core DLLs to build directory
        run: |
          $rocmVersion = if ($env:DETECTED_ROCM_VERSION) { $env:DETECTED_ROCM_VERSION } else { $env:ROCM_VERSION }
          $buildBinPath = "build/bin/${{ matrix.build }}"
          $rocmBinPath = "C:\opt\rocm\bin"
          
          Write-Host "Copying ROCm core DLL files..."
          
          if (Test-Path $rocmBinPath) {
            # Copy files matching patterns
            $filesToCopy = @(
              "amdhip64_*.dll",
              "amd_comgr*.dll", 
              "libhipblas.dll",
              "rocblas.dll",
              "rocsolver.dll",
              "hipblaslt.dll",
              "libhipblaslt.dll",
              "hipblas.dll"
            )
            
            foreach ($pattern in $filesToCopy) {
              $matchingFiles = Get-ChildItem -Path $rocmBinPath -Name $pattern -ErrorAction SilentlyContinue
              if ($matchingFiles) {
                foreach ($file in $matchingFiles) {
                  Copy-Item (Join-Path $rocmBinPath $file) (Join-Path $buildBinPath $file)
                  Write-Host "Copied: $file"
                }
              }
            }
            
            # Copy rocblas/library
            $rocblasLibPath = Join-Path $rocmBinPath "rocblas\library"
            if (Test-Path $rocblasLibPath) {
              Copy-Item -Path $rocblasLibPath -Destination (Join-Path $buildBinPath "rocblas\library") -Recurse -Force
              Write-Host "Copied: rocblas\library"
            }

            # Copy hipblaslt/library
            $hipblasltLibPath = Join-Path $rocmBinPath "hipblaslt\library"
            if (Test-Path $hipblasltLibPath) {
              Copy-Item -Path $hipblasltLibPath -Destination (Join-Path $buildBinPath "hipblaslt\library") -Recurse -Force
              Write-Host "Copied: hipblaslt\library"
            }
          }

      - name: Copy SDL2.dll
        if: matrix.sdl2 == 'ON'
        run: copy "$env:SDL2_DIR/../lib/${{ matrix.s2arc }}/SDL2.dll" build/bin/${{ matrix.build }}

      - name: Copy SDL2.dll
        if: matrix.sdl2 == 'ON'
        run: copy "$env:SDL2_DIR/../lib/${{ matrix.s2arc }}/SDL2.dll" "build/bin/${{ matrix.build }}"

      - name: Pack bin artifacts
        shell: pwsh
        run: |
          # Create unique zip name with target suffix
          $zipName = "whisper-bin-${{ matrix.gfx_target }}-windows-${{ matrix.arch }}.zip"
          Compress-Archive -Path "build/bin/${{ matrix.build }}" -DestinationPath $zipName

      - name: Upload binaries
        if: matrix.sdl2 == 'ON' && needs.determine-tag.outputs.should_release
        uses: actions/upload-artifact@v4
        with:
          # Unique artifact name per matrix job
          name: whisper-bin-${{ matrix.gfx_target }}-windows-${{ matrix.arch }}.zip
          path: whisper-bin-${{ matrix.gfx_target }}-windows-${{ matrix.arch }}.zip

  emscripten:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    strategy:
      matrix:
        build: [Release]

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Setup emsdk
        uses: mymindstorm/setup-emsdk@v14

      - name: Verify
        run: emcc -v

      - name: Build
        run: |
          emcmake cmake . -DCMAKE_BUILD_TYPE=${{ matrix.build }}
          make

  ios-xcode-build:
    runs-on: macos-latest
    needs: determine-tag

    strategy:
      matrix:
        build: [Release]

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Configure
        run: |
          cp models/for-tests-ggml-base.en.bin models/ggml-base.en.bin
          mkdir models/ggml-base.en-encoder.mlmodelc

      - name: Build
        id: cmake_build
        run: |
          sysctl -a
          mkdir build
          cd build
          cmake -G Xcode .. \
            -DGGML_METAL_USE_BF16=ON \
            -DGGML_METAL_EMBED_LIBRARY=ON \
            -DWHISPER_BUILD_EXAMPLES=OFF \
            -DWHISPER_BUILD_TESTS=OFF \
            -DWHISPER_BUILD_SERVER=OFF \
            -DCMAKE_SYSTEM_NAME=iOS \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=14.0 \
            -DCMAKE_XCODE_ATTRIBUTE_DEVELOPMENT_TEAM=ggml
          cmake --build . --config Release -j $(sysctl -n hw.logicalcpu) -- CODE_SIGNING_ALLOWED=NO

      - name: xcodebuild for swift package
        id: xcodebuild
        run: |
          ./build-xcframework.sh

      - name: Build objc example
        run: xcodebuild -project examples/whisper.objc/whisper.objc.xcodeproj -scheme whisper.objc -configuration ${{ matrix.build }} -sdk iphoneos CODE_SIGN_IDENTITY="" CODE_SIGNING_REQUIRED=NO FRAMEWORK_FOLDER_PATH=./build-ios build

      - name: Build swiftui example
        run: xcodebuild -project examples/whisper.swiftui/whisper.swiftui.xcodeproj -scheme WhisperCppDemo -configuration ${{ matrix.build }} -sdk iphoneos CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY= -destination 'generic/platform=iOS' FRAMEWORK_FOLDER_PATH=./build-ios build

      - name: Pack artifacts
        id: pack_artifacts
        run: |
          zip --symlinks -r whisper-${{ needs.determine-tag.outputs.tag_name }}-xcframework.zip build-apple/whisper.xcframework

      - name: Upload artifacts
        if: ${{ needs.determine-tag.outputs.should_release }}
        uses: actions/upload-artifact@v6
        with:
          path: whisper-${{ needs.determine-tag.outputs.tag_name }}-xcframework.zip
          name: whisper-${{ needs.determine-tag.outputs.tag_name }}-xcframework.zip

  android:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    steps:
      - name: Clone
        uses: actions/checkout@v6
        with:
          path: whisper

      - name: Install Java
        uses: actions/setup-java@v5
        with:
          distribution: zulu
          java-version: 21

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3

      - name: Build
        run: |
          cd whisper/examples/whisper.android
          ./gradlew assembleRelease --no-daemon

      - name: Build with external ggml
        run: |
          export PATH_TO_GGML=$PWD/ggml
          cd whisper/examples/whisper.android
          ./gradlew assembleRelease --no-daemon

  android_java:
    runs-on: ubuntu-22.04

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: set up JDK 11
        uses: actions/setup-java@v5
        with:
          java-version: '11'
          distribution: 'temurin'
          cache: gradle

      - name: Setup Android SDK
        uses: android-actions/setup-android@v3
        with:
          cmdline-tools-version: 9.0

      - name: Build
        run: |
          cd examples/whisper.android.java
          chmod +x ./gradlew
          ./gradlew assembleRelease

  bindings-java:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    needs: ['windows']
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v6

      - name: Install Java
        uses: actions/setup-java@v5
        with:
          distribution: zulu
          java-version: 20

      - name: Download Whisper Windows lib
        uses: actions/download-artifact@v7
        with:
          name: whisper_x64.dll

      - name: Download GGML Windows lib
        uses: actions/download-artifact@v7
        with:
          name: ggml_x64.dll

      - name: Download GGML Base Windows lib
        uses: actions/download-artifact@v7
        with:
          name: ggml_base_x64.dll

      - name: Download GGML CPU Windows lib
        uses: actions/download-artifact@v7
        with:
          name: ggml_cpu_x64.dll

      - name: Download SDL2.dll
        uses: actions/download-artifact@v7
        with:
          name: x64_SDL2.dll

      - name: List downloaded files
        shell: pwsh
        run: |
          Get-ChildItem -Path "." -Recurse -Filter "*.dll"

      - name: Move DLL to correct location
        shell: pwsh
        run: |
          New-Item -Path "build\bin\Release" -ItemType Directory -Force

          Copy-Item -Path "whisper.dll" -Destination "build\bin\Release\whisper.dll" -Force
          Write-Host "Copied whisper.dll to build\bin\Release\whisper.dll directory"

          Copy-Item -Path "ggml.dll" -Destination "build\bin\Release\ggml.dll" -Force
          Write-Host "Copied ggml.dll to build\bin\Release\ggml.dll directory"

          Copy-Item -Path "ggml-base.dll" -Destination "build\bin\Release\ggml-base.dll" -Force
          Write-Host "Copied ggml-base.dll to build\bin\Release\ggml-base.dll directory"

          Copy-Item -Path "ggml-cpu.dll" -Destination "build\bin\Release\ggml-cpu.dll" -Force
          Write-Host "Copied ggml-cpu.dll to build\bin\Release\ggml-cpu.dll directory"

          Copy-Item -Path "SDL2.dll" -Destination "build\bin\Release\SDL2.dll" -Force
          Write-Host "Copied SDL2.dll to build\bin\Release\SDL2.dll directory"

      - name: List build release files
        shell: pwsh
        run: |
          Get-ChildItem -Path "build\Release" -Recurse -Filter "*.dll"

      - name: Build
        run: |
          models\download-ggml-model.cmd tiny.en models/
          cd bindings/java
          chmod +x ./gradlew
          ./gradlew build --info

      - name: Pack jar artifacts
        shell: pwsh
        run: |
              Compress-Archive -Path "bindings/java/build/libs/whispercpp-*.jar" -DestinationPath "whispercpp.jar.zip"

      - name: Upload jar
        uses: actions/upload-artifact@v6
        with:
          name: whispercpp.jar.zip
          path: whispercpp.jar.zip

#      - name: Publish package
#        if: ${{ github.ref == 'refs/heads/master' }}
#        uses: gradle/gradle-build-action@v2.4.2
#        with:
#          arguments: publish
#          build-root-directory: bindings/java
#        env:
#          MAVEN_USERNAME: ${{ secrets.JIRA_USER }}
#          MAVEN_PASSWORD: ${{ secrets.JIRA_PASS }}
#          PGP_SECRET: ${{ secrets.GPG_PRIVATE_KEY }}
#          PGP_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}

  quantize:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-22.04

    steps:
      - name: Clone
        uses: actions/checkout@v6

      - name: Test quantize
        run: |
          ./models/download-ggml-model.sh tiny.en
          cmake -B build
          cmake --build build --config Release
          ./build/bin/whisper-quantize models/ggml-tiny.en.bin models/ggml-tiny.en-q4_0.bin q4_0

  release:
    if: ${{ github.event.inputs.create_release == 'true' || github.event.inputs.pre_release_tag != '' || startsWith(github.ref, 'refs/tags/v') }}

    runs-on: ubuntu-latest

    needs:
      - determine-tag
      - ios-xcode-build
      - windows
      - windows-blas
      - windows-cublas
      - windows-rocm
      - ubuntu-rocm

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: ccache
        uses: hendrikmuhs/ccache-action@v1.2.16
        with:
          key: release
          evict-old-files: 1d

      # Downloads all the artifacts from the previous jobs
      - name: Download artifacts
        id: download-artifact
        uses: actions/download-artifact@v7
        with:
          path: ./artifact

      - name: Move artifacts
        id: move_artifacts
        run: mkdir -p ./artifact/release && mv ./artifact/*/*.zip ./artifact/release

      - name: Create release
        id: create_release
        uses: ggml-org/action-create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ needs.determine-tag.outputs.tag_name }}
          prerelease: ${{ github.event.inputs.pre_release_tag != '' }}
          draft: true

      - name: Upload release
        id: upload_release
        uses: actions/github-script@v3
        with:
          github-token: ${{secrets.GITHUB_TOKEN}}
          script: |
            const path = require('path');
            const fs = require('fs');
            const release_id = '${{ steps.create_release.outputs.id }}';
            for (let file of await fs.readdirSync('./artifact/release')) {
              if (path.extname(file) === '.zip') {
                console.log('uploadReleaseAsset', file);
                await github.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: release_id,
                  name: file,
                  data: await fs.readFileSync(`./artifact/release/${file}`)
                });
              }
            }

  coreml-base-en:
    if: ${{ (github.event_name == 'push' && github.ref == 'refs/heads/master') ||
            github.event.inputs.create_release == 'true' ||
            github.event.inputs.pre_release_tag != '' ||
            startsWith(github.ref, 'refs/tags/v') }}
    runs-on: macos-latest
    needs: determine-tag

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Set environment variables
        id: set_vars
        run: |
          echo "MODEL_NAME=base.en" >> $GITHUB_ENV
          echo "GEN_MODEL_NAME=whisper-${{ needs.determine-tag.outputs.tag_name }}-ggml-base.en-encoder.mlmodelc" >> $GITHUB_ENV

      - name: Download model
        run: |
          ./models/download-ggml-model.sh ${{ env.MODEL_NAME }}

      - name: Generate CoreML model
        run: |
          python3.11 -m venv venv
          source venv/bin/activate
          pip install ane_transformers openai-whisper coremltools
          ./models/generate-coreml-model.sh ${{ env.MODEL_NAME }}

  vad:
    if: ${{ github.event_name == 'push' || github.event_name == 'pull_request' ||
            github.event.inputs.run_type == 'full-ci' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Build
        shell: bash
        run: |
          cmake -B build
          cmake --build build --config Release

      - name: Test
        shell: bash
        run: |
          ctest -R ^test-vad$ --test-dir build --output-on-failure -VV

# TODO: simplify the following workflows using a matrix
  ggml-ci-x64-cpu-low-perf:
    runs-on: ubuntu-22.04

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: ccache
        uses: ggml-org/ccache-action@v1.2.16
        with:
          key: ggml-ci-x64-cpu-low-perf
          evict-old-files: 1d

      - name: Dependencies
        id: depends
        run: |
          sudo apt-get update
          sudo apt-get install build-essential libcurl4-openssl-dev

      - name: Test
        id: ggml-ci
        run: |
          LLAMA_ARG_THREADS=$(nproc) GG_BUILD_LOW_PERF=1 bash ./ci/run.sh ./tmp/results ./tmp/mnt

  ggml-ci-arm64-cpu-low-perf:
    runs-on: ubuntu-22.04-arm

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: ccache
        uses: ggml-org/ccache-action@v1.2.16
        with:
          key: ggml-ci-arm64-cpu-low-perf
          evict-old-files: 1d

      - name: Dependencies
        id: depends
        run: |
          sudo apt-get update
          sudo apt-get install build-essential libcurl4-openssl-dev

      - name: Test
        id: ggml-ci
        run: |
          LLAMA_ARG_THREADS=$(nproc) GG_BUILD_LOW_PERF=1 bash ./ci/run.sh ./tmp/results ./tmp/mnt

  ggml-ci-x64-cpu-high-perf:
    runs-on: ubuntu-22.04

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: ccache
        uses: ggml-org/ccache-action@v1.2.16
        with:
          key: ggml-ci-x64-cpu-high-perf
          evict-old-files: 1d

      - name: Dependencies
        id: depends
        run: |
          sudo apt-get update
          sudo apt-get install build-essential libcurl4-openssl-dev

      - name: Test
        id: ggml-ci
        run: |
          LLAMA_ARG_THREADS=$(nproc) bash ./ci/run.sh ./tmp/results ./tmp/mnt

  ggml-ci-arm64-cpu-high-perf:
    runs-on: ubuntu-22.04-arm

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: ccache
        uses: ggml-org/ccache-action@v1.2.16
        with:
          key: ggml-ci-arm64-cpu-high-perf
          evict-old-files: 1d

      - name: Dependencies
        id: depends
        run: |
          sudo apt-get update
          sudo apt-get install build-essential libcurl4-openssl-dev

      - name: Test
        id: ggml-ci
        run: |
          LLAMA_ARG_THREADS=$(nproc) GG_BUILD_NO_SVE=1 GG_BUILD_NO_BF16=1 GG_BUILD_EXTRA_TESTS_0=1 bash ./ci/run.sh ./tmp/results ./tmp/mnt

  ggml-ci-arm64-cpu-high-perf-sve:
    runs-on: ubuntu-22.04-arm

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: ccache
        uses: ggml-org/ccache-action@v1.2.16
        with:
          key: ggml-ci-arm64-cpu-high-perf-sve
          evict-old-files: 1d

      - name: Dependencies
        id: depends
        run: |
          sudo apt-get update
          sudo apt-get install build-essential libcurl4-openssl-dev

      - name: Test
        id: ggml-ci
        run: |
          LLAMA_ARG_THREADS=$(nproc) GG_BUILD_NO_BF16=1 GG_BUILD_EXTRA_TESTS_0=1 bash ./ci/run.sh ./tmp/results ./tmp/mnt

  ggml-ci-x64-nvidia-cuda:
    runs-on: [self-hosted, Linux, X64, NVIDIA]

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: Test
        id: ggml-ci
        run: |
          nvidia-smi
          GG_BUILD_CUDA=1 bash ./ci/run.sh ~/results/whisper.cpp /mnt/whisper.cpp

  ggml-ci-x64-nvidia-vulkan-cm:
    runs-on: [self-hosted, Linux, X64, NVIDIA]

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: Test
        id: ggml-ci
        run: |
          vulkaninfo --summary
          GG_BUILD_VULKAN=1 GGML_VK_DISABLE_COOPMAT2=1 bash ./ci/run.sh ~/results/whisper.cpp /mnt/whisper.cpp

  ggml-ci-x64-nvidia-vulkan-cm2:
    runs-on: [self-hosted, Linux, X64, NVIDIA, COOPMAT2]

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: Test
        id: ggml-ci
        run: |
          vulkaninfo --summary
          GG_BUILD_VULKAN=1 bash ./ci/run.sh ~/results/whisper.cpp /mnt/whisper.cpp

  ggml-ci-x64-cpu-amx:
    runs-on: [self-hosted, Linux, X64, CPU, AMX]

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: Test
        id: ggml-ci
        run: |
          bash ./ci/run.sh ~/results/whisper.cpp /mnt/whisper.cpp

  ggml-ci-mac-metal:
    runs-on: [self-hosted, macOS, ARM64]

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: Test
        id: ggml-ci
        run: |
          GG_BUILD_METAL=1 bash ./ci/run.sh ~/results/whisper.cpp ~/mnt/whisper.cpp

  ggml-ci-mac-vulkan:
    runs-on: [self-hosted, macOS, ARM64]

    steps:
      - name: Clone
        id: checkout
        uses: actions/checkout@v6

      - name: Test
        id: ggml-ci
        run: |
          vulkaninfo --summary
          GG_BUILD_VULKAN=1 bash ./ci/run.sh ~/results/whisper.cpp ~/mnt/whisper.cpp
